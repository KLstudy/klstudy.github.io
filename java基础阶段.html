<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>java基础阶段</title>
</head>
<body>

<ul>
    <li><a href="#01">java 语言概述</a></li>
    <li><a href="#02">java 基本语法</a></li>
    <li><a href="#03">java 数组</a></li>
    <li><a href="#04">java 面向对象</a></li>
    <li><a href="#05">java 异常处理</a></li>
</ul>











<h1>java 基础阶段</h1>
<br>

<h2 id="01">java 语言概述</h2>
<h3>常用的DOS命令</h3>

<ul>
    <li>dir：列出当前目录下的文件以及文件夹</li>
    <li>md：创建目录</li>
    <li>rd：删除目录</li>
    <li>cd：进入指定目录</li>
    <li>cd..：退回到上级目录</li>
    <li>cd\：退回到根目录</li>
    <li>del：删除文件</li>
    <li>exit：退出DOS命令行</li>
</ul>


<h3>第一个Java程序</h3>

<pre>
public class HelloWorld{  
    public static void main(String[] args){  
        System.out.println("HelloWorld");  
    }  
}  
</pre>
<br>


<h2 id="02">java 基本语法</h2>


<h3>关键字与标识符</h3>

<ol>
    <li>关键字：被Java语言赋予了特殊含义，用作专门用途的字符串</li>
    <li>标识符：凡是自己可以定义名字的地方都是标识符</li>
    <ol>
        <li>标识符的命名规则：</li>
        <ol>
            <li>由字母，数字，下划线和"$"组成</li>
            <li>不可以以数字开头</li>
            <li>严格区分大小写</li>
            <li>不可以用关键字作为标识符</li>
        </ol>
        <li>标识符的命名规范（见名知意）：</li>
        <ol>
            <li>包名：全部小写</li>
            <li>类名、接口名等等：驼峰命名</li>
            <li>变量名、方法名:首字母小写，其余单词驼峰命名</li>
            <li>常量名：全部大写</li>
        </ol>
    </ol>
</ol>

<h3>变量的使用</h3>

<h4>变量的分类</h4>

<p>按照数据类型分类</p>
<blockquote>
    <p>基本数据类型（8种基本数据类型）
    </p>
    <blockquote>
        <p>数值型</p>
        <blockquote>
            <p>整型(type,short,int,long[要以&quot;l&quot;或者&quot;L&quot;结尾])<br />
                浮点型(float[要以&quot;f&quot;或者&quot;F&quot;结尾],double)</p>
        </blockquote>
        <p>字符型（char）<br />
            布尔型 （boolean）</p>
    </blockquote>
    <p>引用数据类型：类（class）、接口（interface）、数组（array[]）
    </p>
</blockquote>
<p>按照声明位置分类
</p>
<blockquote>
    <p>成员变量
    </p>
    <blockquote>
        <p>实例变量（非静态变量）  <br />
            类变量  （静态变量）
        </p>
    </blockquote>
    <p>局部变量：定义在，形参，方法体，循环体，代码块等等</p>
</blockquote>
</blockquote>
<h3>基本数据类型之间的运算</h3>
<blockquote>
    <p>只涉及到七种基本数据类型（除boolean之外)
    </p>
</blockquote>
<h4>自动类型转换</h4>
<ol>
    <li>当容量小的(short)数据类型的变量与容量大的(int)数据类型的变量做运算时，结果自动提升为容量大(int)的数据类型。</li>
    <li>byte 、char 、short --&gt; int --&gt; long --&gt; float --&gt; double</li>
    <li>特别的：当byte、char、short三种类型的变量做运算时，结果为int型</li>
</ol>
<h4>强制类型转换</h4>
<blockquote>
    <p>就是自动类型转换的逆操作</p>
</blockquote>
<h4>String与基本数据类型的运算（说明：String属于引用数据类型）：</h4>
<blockquote>
    <p>String也可以与8种基本数据类型进行运算，但只能进行连接运算，使用&quot;+&quot;，此时的&quot;+&quot;号作为连接符</p>
</blockquote>
<h3>运算符</h3>
<h4>算数运算符</h4>
<pre>
+ - * / %(取余：也叫取模) i++ ++i i-- --i
</pre>
<h4>赋值运算符</h4>
<pre>
=  +=  -=  *=  /=  %=
</pre>
<h4>比较运算符</h4>
<pre>
== != >  <  >=  <=  instanceof（判断某个对象属不属于某一个类）
</pre>
<h4>逻辑运算符</h4>
<pre>
& &&(短路与)  |  ||(短路或) !（非）  ^（异或）
</pre>
<h4>位运算符</h4>
<pre>
<<  >> >>>      简单：&  |  ^  ~
特别说明：
左移运算符（<<）: M << n  = M * 2的n次方，左移右边补0
右移运算符（>>）: M << n  = M / 2的n次方，右移左边补1
无符号右移（>>>）:无符号右移(>>>)只对32位和64位有意义，补位的时候补0
</pre>
<h4>三元运算符</h4>
<pre>
（条件表达式）？ 表达式1 ： 表达式2
说明：条件为真则执行表达式1，否则执行表达式2
</pre>
<h3>流程控制</h3>
<h4>分支结构</h4>
<pre>
if - else if - else;不赘述
</pre>
<h4>循环结构</h4>
<h5>普通for循环（常用于遍历操作）</h5>
<pre name="code" class="java">
for(int i = 0;i < 100;i++){
    System.out.println(i);//遍历一百以内的整数
}
</pre>
<h5>while循环（常用于代码的多次执行）</h5>
<pre>
int i;
while(true){
    if(i < 100){
        System.out.prinfln(i);
		i++;
    }else{
		break;
	}
}

</pre>
<h5>增强for循环</h5>
<pre>
String[] str = new String[]{"AA","BB","CC"};
for(String s : str){
	System.out.println(s)
}
</pre>
<p><br></p>
<h2 id="03">java 数组</h2>
<blockquote>
    <p>概念：多个相同类型数据一定顺序排列的集合，并使用一个名字命名，
        并通过编号的方式对这些数据进行统一管理。<br />
        特点：</p>
    <blockquote>
        <p>数组是有序排列的<br />
            数组的长度一旦确定便不可更改<br />
            数组属于引用数据类型的变量，数组中既可以存储引用数据类型的数据，也可以存放基本数据类型的数据
            分类：
            一维数组
            多维数组</p>
    </blockquote>
</blockquote>
<h3>一维数组</h3>
<pre>
//一维数组的初始化
int[] arr = new int[]{1,2,3,4};//静态初始化
int[] arr1 = new int[20];//动态初始化，只指定数组长度，赋值后续进行
//特别的数组可以进行类型推断
int[] arr2 = {1,2,3,4,4};

//一维数组的索引
arr[0];//索引arr数组的第0个元素
//一维数组长度的获取
int len = arr.length;//获取数组的长度，注意这里不是数组的元素个数，而是数组的长度
//一维数组的遍历（这里也可以使用增强for循环）
for(int i = 0;i < arr.length;i++){
    System.out.println(arr[i]);
}
</pre>
<h3>二维数组</h3>
<blockquote>
    <p>这里应该有一行;//二维数组的静态初始化    <br />
        int[][] arr4 = new int[3][2];//二维数组的动态初始化一<br />
        int[][] arr4 = new int[3][];//二维数组的动态初始化二
    </p>
    <blockquote>
        <p>没有动态初始化三，不要期待
        </p>
        <p>说明：二维数组说白了就是数组的嵌套</p>
    </blockquote>
</blockquote>
<h3>数组的常见算法</h3>
<h4>1，数组的赋值与复制的区别</h4>
<pre>
int[] arr = new int[]{1,2,3};
//1.1 数组的赋值
int[] arr1;
arr1 = arr;//这在底层的原理是将arr的地址赋给了arr1，他们俩指向的依然是同一块内存空间
//1.2 数组的复制
String[] str = new String[]{"AA","BB","CC"};
String[] str1 = new String[str.length];
for(int i = 0;i < str.length;i++){
	str1[i] = str[i];
}
</pre>
<h4>2，数组元素的反转</h4>
<pre>
     /*
    实现数组的反转
     */
    @Test
    public void test(){
        int[] arr = new int[]{1,2,3,4,5};

        for(int i = 0,j = arr.length - 1;i < j;i++,j--){
            int temp = arr[i];
            arr[i] = arr[j];
            arr[j] = temp;
        }
        for(int i : arr){
            System.out.println(i);
        }
    }

</pre>
<h4>3，数组中元素的查找</h4>
<pre>

     /*
    线性查找数组中的元素
     */
    @Test
    public void test1(){
        int[] arr = new int[]{1,2,3,4,7};

        //查找2
        for(int i = 0;i < arr.length;i++){
            if(arr[i] == 7){
                System.out.println("找到啦，7 的位置是：" + i);
                break;
            }
            if(i == 4){
                System.out.println("没有找到7！");
            }
        }
    }

</pre>
<pre>

     /*
    二分法查找数组元素
    前提：数组必须是有序的
     */
    @Test
    public void test2(){
        int[] arr = new int[]{1,2,3,4,7};
        int low = 0;
        int high = arr.length - 1;
        boolean isFind = false;
        while(low <= high){
            int mid = (low + high) / 2;
            if(7 == arr[mid]){
                System.out.println(mid);
                isFind = true;
                break;
            }
            if(7 < arr[mid]){
                high = mid - 1;
            }
            if(7 > arr[mid]){
                low = mid + 1;
            }
        }
        if(isFind == false){
            System.out.println("没找到");
        }
    }

</pre>
<h4>4，数组的排序</h4>
<pre>
     /*
    冒泡排序
     */
    @Test
    public void test3() {
        int[] arr = new int[]{43, 32, 76, -98, 0, 64, 33, -21, 32, 99};

        for (int i = 0; i < arr.length - 1; i++) {
            for (int j = 0; j < arr.length - 1 - i; j++) {
                if (arr[j] > arr[j + 1]) {
                    int temp = arr[j];
                    arr[j] = arr[j + 1];
                    arr[j + 1] = temp;
                }
            }
        }
        for (int i : arr) {
            System.out.println(i);
        }
    }
</pre>
<h4>5，Arrays工具类</h4>
<pre>
        //1.boolean equals(int[] a,int[] b):判断两个数组是否相等。
		int[] arr1 = new int[]{1,2,3,4};
		int[] arr2 = new int[]{1,3,2,4};
		boolean isEquals = Arrays.equals(arr1, arr2);
		System.out.println(isEquals);

		//2.String toString(int[] a):输出数组信息。
		System.out.println(Arrays.toString(arr1));


		//3.void fill(int[] a,int val):将指定值填充到数组之中。
		Arrays.fill(arr1,10);
		System.out.println(Arrays.toString(arr1));


		//4.void sort(int[] a):对数组进行排序。
		Arrays.sort(arr2);
		System.out.println(Arrays.toString(arr2));

		//5.int binarySearch(int[] a,int key)
		int[] arr3 = new int[]{-98,-34,2,34,54,66,79,105,210,333};
		int index = Arrays.binarySearch(arr3, 210);
		if(index >= 0){
			System.out.println(index);
		}else{
			System.out.println("未找到");
		}

</pre>
<h4>6，数组常见异常</h4>
<blockquote>
    <p>角标越界异常
    </p>
    <blockquote>
        <p>常见于索引时，给定角标值超出数组已有范围
        </p>
    </blockquote>
    <p>空指针异常
    </p>
    <blockquote>
        <p>一般发生在，调用的数组元素未被初始化，即值还为null</p>
    </blockquote>
</blockquote>
<h2 id="04">java 面向对象</h2>
<blockquote>
    <p>面向对象的三条主线</p>
    <blockquote>
        <p>1.Java类及类的成员：属性、方法、构造器；代码块、内部类<br />
            2.面向对象的大特征：封装性、继承性、多态性、(抽象性)<br />
            3.其它关键字：this、super、static、final、abstract、interface、package、import等</p>
    </blockquote>
</blockquote>
<h3>类与对象</h3>
<blockquote>
    <p>两个概念</p>
    <blockquote>
        <p>类：对一类事物的描述，是抽象的、概念上的定义<br />
            对象：是实际存在的该类事物的每个个体，因而也称为实例(instance)
        </p>
    </blockquote>
</blockquote>
<h4>面向对象</h4>
<p><a href="https://github.com/KLELee/KLELee.github.io/blob/main/Person.java">
    <font size="5">&emsp;&emsp;面向对象——属性、方法、构造器相关（<====戳）</font>
</a><br><a href="https://github.com/KLELee/KLELee.github.io/blob/main/Student.java">
    <font size="5">&emsp;&emsp;面向对象——继承性（<====戳）</font>
</a><br><a href="https://github.com/KLELee/KLELee.github.io/blob/main/OPPTest.java">
    <font size="5">&emsp;&emsp;面向对象——多态性（<====戳）</font>
</a><br></p>
<h4>Object 类的使用</h4>
<blockquote>
    <p>说明：
    </p>
    <blockquote>
        <p>1,Object类是所有java类的根父类<br />
            2,如果在类中没有显式的去继承其他的类，那么默认这个类的父类就是Object类<br />
            3,因为其是所有类的根父类，所以Object类中的所有方法具有通用性</p>
        <blockquote>
            <p>常用的方法有：<br />
                equals() / toString() / getClass() /hashCode() / clone() / finalize()wait() 、 notify()、notifyAll()
            </p>
        </blockquote>
        <p>4,开发中，我们常常需要对自定义的类进行重写equals()方法和toString()方法</p>
    </blockquote>
</blockquote>
<h4>单元测试方法</h4>
<pre>
@Test
public void test(){
    里面写要测试的代码
}
</pre>
<h4>包装类的使用</h4>
<blockquote>
    <p>说明：</p>
    <blockquote>
        <p>为了使基本数据类型的变量具有类的特征，引入包装类。</p>
    </blockquote>
</blockquote>
<h5>各类型之间的转换</h5>
<ol>
    <li>基本数据类型&lt;---&gt;包装类：JDK 5.0 新特性：自动装箱 与自动拆箱
    </li>
    <li>基本数据类型、包装类---&gt;String:调用String重载的valueOf(Xxx xxx)
    </li>
    <li>String---&gt;基本数据类型、包装类:调用包装类的parseXxx(String s)
    </li>
</ol>
<h3>static 关键字（属性、方法、代码块、内部类）</h3>
<blockquote>
    <p>主要用来修饰类的内部结构属性、方法、代码块、内部类</p>
</blockquote>
<h4>static 来修饰属性</h4>
<blockquote>
    <p>实例变量（非静态属性）</p>
    <blockquote>
        <p>我们创建了类的多个对象，每个对象都独立的拥一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</p>
    </blockquote>
    <p>类变量（静态属性）</p>
    <blockquote>
        <p>1，我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。<br />
            2，静态变量通过类的加载而加载，在实际应用中可以通过类名去调用，也就是说静态变量的加载要早于对象的创建</p>
    </blockquote>
</blockquote>
<h4>static 来修饰方法</h4>
<blockquote>
    <p>静态方法、类方法
    </p>
    <blockquote>
        <p>1，随着类的加载而加载，可以通过&quot;类.静态方法&quot;的方式进行调用<br />
            2，<br />
            静态方法中，只能调用静态的方法或属性<br />
            非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</p>
    </blockquote>
</blockquote>
<h5>如何判定属性和方法应该使用static关键字：</h5>
<blockquote>
    <p>关于属性</p>
    <blockquote>
        <p>1，属性是可以被多个对象所共享的，不会随着对象的不同而不同的。<br />
            2，类中的常量也常常声明为static
        </p>
    </blockquote>
    <p>关于方法</p>
    <blockquote>
        <p>1，操作静态属性的方法，通常设置为static的<br />
            2，工具类中的方法，习惯上声明为static的。 比如：Math、Arrays、Collections
        </p>
    </blockquote>
</blockquote>
<h5>单例模式</h5>
<pre>
 /**
 * @author Eric    Email: doeric@sina.com
 * @creat 2020-09-16-8:18
 * @description  单例模式复习
 * 饿汉式1：
 */
public class SingletonTest {
    //1，私有化类的构造器，致使在外部不能调用构造器来创建新的对象，从而形成单例模式
    private SingletonTest(){

    }

    //2，内部创建类的对象
    //4，由于静态的方法只能调用静态的属性和方法，所以这里的对象也应该造成静态的
    private static SingletonTest single = new SingletonTest();

    //3，创建一个public方法，来返回这个对象
    public static SingletonTest show(){
        return single;
    }
}
</pre>
<pre>
/**
 * @author Eric    Email: doeric@sina.com
 * @creat 2020-09-16-8:24
 * @description  单例模式
 * 饿汉式2
 */
public class SingletonTest1 {

    //1，创建一个私有的构造器
    private SingletonTest1(){

    }
    //2，创建一个当前类的对象，没初始化
    //4，由于静态的方法只能调用静态的属性和方法，所以这里的对象也只能声明成静态的
    private static SingletonTest1 single1 = null;
    static {//静态代码块，随着类的加载而执行，非静态代码块随着对象的创建而执行
        single1 = new SingletonTest1();
    }

    //3，创建一个public的static的方法来返回这个对象
    public static SingletonTest1 show(){
        return single1;
    }
}
</pre>
<pre>
/**
 * @author Eric    Email: doeric@sina.com
 * @creat 2020-09-16-8:31
 * @description  懒汉式，这个写法中线程式不安全的，所以还需要更新
 */
public class SingletonTest2 {
    //1，创建一个私有的构造器
    private SingletonTest2(){}

    //2，声明一个私有的对象，不赋值
    //4，由于静态的方法只能调用静态的属性和方法，所以这里的对象也只能声明成静态的
    private static SingletonTest2 single2 = null;
    //3，创建一个公共的静态方法，在方法内对对象进行赋值创建
    public static SingletonTest2 show(){
        if(single2 == null){
            single2 = new SingletonTest2();
        }

        return single2;
    }
</pre>
<pre>
/**
 * @author Eric    Email: doeric@sina.com
 * @creat 2020-09-16-10:32
 * @description  将懒汉式改成线程安全的
 */
public class SingletonTest3 {
    //1，创建一个私有的构造器
    private SingletonTest3(){}

    //2，声明一个私有的对象，不赋值
    //4，由于静态的方法只能调用静态的属性和方法，所以这里的对象也只能声明成静态的
    private static SingletonTest3 single3 = null;


    //3，创建一个公共的静态方法，在方法内对对象进行赋值创建
    // 方法一,同步方法 synchronized，或者用同步代码块把if语句包起来
    public static synchronized SingletonTest3 show(){
//        if(single3 == null){
//
//            single3 = new SingletonTest3();
//        }
//
//        return single3;
// 方式二
        if(single3 == null){
            synchronized (SingletonTest3.class){
                if(single3 == null){
                    single3 = new SingletonTest3();
                }
            }
        }
        return single3;

    }



}
</pre>
<h3>代码块</h3>
<h4>静态代码块：</h4>
<blockquote>
    <p>内部可以输出语句<br />
        随着类的加载而执行,而且只执行一次<br />
        作用：初始化类的信息<br />
        如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行<br />
        静态代码块的执行要优先于非静态代码块的执行<br />
        静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构
    </p>
</blockquote>
<h5>非静态代码块：</h5>
<blockquote>
    <p>内部可以输出语句<br />
        随着对象的创建而执行<br />
        每创建一个对象，就执行一次非静态代码块<br />
        作用：可以在创建对象时，对对象的属性等进行初始化<br />
        如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行<br />
        非静态代码块内可以调用静态的属性、静态的方法，或非静态的属性、非静态的方法
    </p>
</blockquote>
<h3>final 关键字（类、方法、变量）</h3>
<blockquote>
    <p>final 用来修饰一个类:此类不能被其他类所继承。
    </p>
    <blockquote>
        <p>比如：String类、System类、StringBuffer类
        </p>
    </blockquote>
    <p>final 用来修饰方法：表明此方法不可以被重写
    </p>
    <blockquote>
        <p>比如：Object类中getClass();
        </p>
    </blockquote>
    <p>final 用来修饰变量：此时的&quot;变量&quot;就称为是一个常量
    </p>
    <blockquote>
        <p>final修饰属性：
        </p>
        <blockquote>
            <p>可以考虑赋值的位置：显式初始化、代码块中初始化、构造器中初始化
            </p>
        </blockquote>
        <p>final修饰局部变量：
        </p>
        <blockquote>
            <p>尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值。 </p>
        </blockquote>
    </blockquote>
    <p>static final 用来修饰属性：全局常量
    </p>
</blockquote>
<h3>abstract 关键字（类、方法）</h3>
<h4>abstract修饰类：抽象类</h4>
<blockquote>
    <p>1，此类不能实例化<br />
        2，抽象类中一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）<br />
        3，开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作 ---&gt;抽象的使用前提：继承性
    </p>
</blockquote>
<h4>abstract修饰方法：抽象方法</h4>
<blockquote>
    <p>1，抽象方法只方法的声明，没方法体<br />
        2，包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。<br />
        3，
    </p>
    <blockquote>
        <p>3.1 若子类重写了父类中的所的抽象方法后，此子类方可实例化  <br />
            3.2 若子类没重写父类中的所的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰
        </p>
    </blockquote>
</blockquote>
<h4>interface 接口</h4>
<blockquote>
    <p>1.接口使用interface来定义<br />
        2.Java中，接口和类是并列的两个结构<br />
        3.如何定义接口：定义接口中的成员
    </p>
    <blockquote>
        <p>3.1 JDK7及以前：只能定义全局常量和抽象方法
        </p>
        <blockquote>
            <p>全局常量：public static final的.但是书写时，可以省略不写<br />
                抽象方法：public abstract的
            </p>
        </blockquote>
        <p>3.2 JDK8：除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略</p>
    </blockquote>
    <ol>
        <li>接口中不能定义构造器的！意味着接口不可以实例化</li>
        <li>Java开发中，接口通过让类去实现(implements)的方式来使用.</li>
    </ol>
    <blockquote>
        <p>如果实现类覆盖了接口中的所抽象方法，则此实现类就可以实例化<br />
            如果实现类没覆盖接口中所的抽象方法，则此实现类仍为一个抽象类
        </p>
    </blockquote>
    <ol>
        <li>Java类可以实现多个接口   ---&gt;弥补了Java单继承性的局限性
        </li>
    </ol>
    <blockquote>
        <p>格式：class AA extends BB implements CC,DD,EE
        </p>
    </blockquote>
    <ol>
        <li>
            <p>接口与接口之间可以继承，而且可以多继承</p>
        </li>
        <li>
            <p>接口的具体使用，体现多态性</p>
        </li>
        <li>接口，实际上可以看做是一种规范</li>
    </ol>
</blockquote>
<h3>内部类</h3>
<blockquote>
    <p>1.定义：Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类.<br />
        2.内部类的分类：
    </p>
    <blockquote>
        <p>成员内部类（静态、非静态 ） <br />
            局部内部类(方法内、代码块内、构造器内)
        </p>
    </blockquote>
    <p>3.成员内部类的理解：
    </p>
    <blockquote>
        <p>一方面，作为外部类的成员：
        </p>
        <blockquote>
            <p>调用外部类的结构<br />
                可以被static修饰<br />
                可以被4种不同的权限修饰
            </p>
        </blockquote>
        <p>另一方面，作为一个类：
        </p>
        <blockquote>
            <p>类内可以定义属性、方法、构造器等<br />
                可以被final修饰，表示此类不能被继承。言外之意，不使final，就可以被继承<br />
                可以被abstract修饰
            </p>
        </blockquote>
    </blockquote>
</blockquote>
<h3>static、final、abstract、interface、内部类部分代码</h3>
<p><a href="https://github.com/KLELee/KLELee.github.io/blob/main/KeyTest.java">
    <font size="5">&emsp;&emsp;static、代码块、内部类（<====戳）</font>
</a><br></p>
<p><a href="https://github.com/KLELee/KLELee.github.io/blob/main/ReviewTest.java">
    <font size="5">&emsp;&emsp;Interface（<====戳）</font>
</a><br></p>
<p><a href="https://github.com/KLELee/KLELee.github.io/blob/main/FinalTest.java">
    <font size="5">&emsp;&emsp;final（<====戳）</font>
</a><br></p>
<p><a href="https://github.com/KLELee/KLELee.github.io/blob/main/AbstractTest.java">
    <font size="5">&emsp;&emsp;abstract（<====戳）</font>
</a><br></p>
<h2 id="05">java 异常处理</h2>
<h3>对try-catch-finally的理解</h3>
<blockquote>
    <p>整个可能出现代码块的程序，都写在代码块当中。如果程序正常结束就不会进入catch部分，只是接着进入finally块，那么就说一说finally块，这个块里面的代码，不管程序怎么结束都会执行，哪怕程序出现了异常，也会执行它，因此可以在里面写一些一定要执行的程序。比如后面要说到的流资源的关闭，最好就写在finally里面<br>
        而对于catch块，也就是说当程序非正常结束，也就是说出现了异常，此时就会执行catch代码块中的程序，一般都是报出当前的异常。</p>
</blockquote>
<h3>手动抛出异常类</h3>
<blockquote>
    <p>throw new Exception(”您输入的数据非法“)；//就是以这样的形式告诉客户，不要慌！</p>
</blockquote>
<h3>如何自定义一个异常类？</h3>
<pre>
/*
 * 如何自定义异常类？
 * 1. 继承于现的异常结构：RuntimeException 、Exception
 * 2. 提供全局常量：serialVersionUID
 * 3. 提供重载的构造器
 *
 */
public class MyException extends Exception{

	static final long serialVersionUID = -7034897193246939L;

	public MyException(){

	}

	public MyException(String msg){
		super(msg);
	}
}
</pre>

</body>
</html>